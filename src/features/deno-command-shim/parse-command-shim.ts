import { CommandShim } from "./command-shim.type.ts";
import { ExecCommand } from "./exec-command.type.ts";
import { parseExecCommand } from "./parse-exec-command.ts";
import { ModuleUrlSegments } from "../deno-module-registries/module-url-segments.type.ts";
import { DenoModuleRegistry } from "../deno-module-registries/deno-module-registry.type.ts";
import { detectModuleRegistry } from "../deno-module-registries/detect-module-registry.ts";
import { error, Result, value } from "../../deps/defekt.ts";
import { ShimPotentiallyInvalid } from "../../errors/ShimPotentiallyInvalid.ts";

export interface ParseCommandShimOptions {
  /**
   * Default: true
   * If set to false, parsing function will not validate,
   * whether it was passed a deno shim or not.
   */
  validateDenoShim: boolean;
}

const defaultOptions: ParseCommandShimOptions = {
  validateDenoShim: true,
};

/**
 * @param shimPath the path of the command shim
 * @param shimContent the content of the command shim as string
 * (so that this parser does not need to load the file itself - better for testing)
 */
export function parseCommandShim(
  shimPath: string,
  shimContent: string | string[],
  options: Partial<ParseCommandShimOptions> = {},
): Result<CommandShim, ShimPotentiallyInvalid> {
  const { validateDenoShim } = { ...defaultOptions, ...options };

  const shimLines = (typeof shimContent === "string")
    ? shimContent.split("\n")
    : shimContent;
  const [_shebang, denoComment, commandString] = shimLines;

  if (validateDenoShim && denoComment !== "# generated by deno install") {
    return error(
      new ShimPotentiallyInvalid({
        message:
          `Command Shim "${shimPath}" may not have been generated by "deno install"! 
           Force proceed by running again with --validateDenoShim=false. 
          
           File Content: 
      
           ${shimContent}`,
        data: shimContent,
      }),
    );
  }

  const execCommand: ExecCommand = parseExecCommand(commandString);
  const moduleRegistry: DenoModuleRegistry = detectModuleRegistry(
    execCommand.moduleURL,
  );

  const moduleUrlSegments: ModuleUrlSegments = moduleRegistry
    .parseModuleUrlSegments(execCommand.moduleURL);

  return value({
    path: shimPath,
    lines: shimLines,
    commandString,
    moduleRegistry,
    execCommand,
    moduleUrlSegments,
  });
}

import { DenoCommandShim } from "./deno-command-shim.type.ts";
import { parseExecCommand } from "./parse-exec-command";

export interface ParseDenoCommandShimOptions {
  /**
   * Default: true
   * If set to false, parsing function will not validate,
   * whether it was passed a deno shim or not.
   */
  validateDenoShim: boolean;
}

const defaultOptions: ParseDenoCommandShimOptions = {
  validateDenoShim: true,
};

/**
 * @param shimPath the path of the command shim
 * @param shimContent the content of the command shim as string
 * (so that this parser does not need to load the file itself - better for testing)
 */
export function parseDenoCommandShim(
  shimPath: string,
  shimContent: string | string[],
  options: Partial<ParseDenoCommandShimOptions> = {},
): DenoCommandShim {
  const { validateDenoShim } = { ...defaultOptions, ...options };

  const shimLines = (typeof shimContent === "string")
    ? shimContent.split("\n")
    : shimContent;
  const [_shebang, denoComment, commandString] = shimLines;

  if (validateDenoShim && denoComment !== "# generated by deno install") {
    throw new Deno.errors.InvalidData(
      `Command Shim "${shimPath}" may not have been generated by "deno install"! 
      Force proceed by running again with --validateDenoShim=false. 
    
      File Content: 
 
      ${shimContent}`,
    );
  }

  const execCommand = parseExecCommand(commandString);

  return {
    path: shimPath,
    lines: shimLines,
    commandString,
    execCommand,
  };
}
